<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Activity Time Tracker</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #f97316;
            --primary-light: #fb923c;
            --primary-dark: #ea580c;
            --primary-gradient: linear-gradient(135deg, #f97316, #fb923c);
            --success-color: #22c55e;
            --warning-color: #f59e0b;
            --danger-color: #ef4444;
            --text-primary: #f3f4f6;
            --text-secondary: #9ca3af;
            --bg-primary: #111827;
            --bg-secondary: #1f2937;
            --bg-tertiary: #374151;
            --border-color: #4b5563;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.3);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.4);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
            --shadow-orange: 0 4px 6px -1px rgba(249, 115, 22, 0.2);
            --achievement-bronze: #cd7f32;
            --achievement-silver: #c0c0c0;
            --achievement-gold: #ffd700;
            --heatmap-0: #161b22;
            --heatmap-1: #4c1d06;
            --heatmap-2: #7c2d12;
            --heatmap-3: #ea580c;
            --heatmap-4: #fb923c;
            --character-size: 120px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.5;
        }

        .container {
            width: 100%;
            max-width: 1200px;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2rem;
            margin: 0 auto;
        }

        .timer-container {
            background: linear-gradient(145deg, var(--bg-secondary), var(--bg-tertiary));
            padding: 2.5rem;
            border-radius: 1rem;
            box-shadow: var(--shadow-lg);
            text-align: center;
            width: 100%;
            max-width: 600px;
            border: 1px solid var(--border-color);
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }

        .timer-display {
            font-size: 4rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--primary-color);
            letter-spacing: -0.025em;
            text-shadow: 0 2px 4px rgba(249, 115, 22, 0.2);
            user-select: none;
            pointer-events: none;
        }

        .total-display {
            font-size: 1.25rem;
            margin-bottom: 1.5rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-bottom: 1.5rem;
        }

        .tag-input {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            margin-bottom: 1.5rem;
            width: 100%;
            max-width: 300px;
            font-size: 1rem;
            transition: border-color 0.2s;
        }

        .tag-input:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(249, 115, 22, 0.2);
        }

        button {
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            font-weight: 500;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0));
            opacity: 0;
            transition: opacity 0.2s;
        }

        button:hover::before {
            opacity: 1;
        }

        #startBtn {
            background: var(--primary-gradient);
            color: white;
        }

        #pauseBtn {
            background: linear-gradient(135deg, #f59e0b, #fbbf24);
            color: white;
        }

        #resetBtn {
            background: linear-gradient(135deg, #ef4444, #f87171);
            color: white;
        }

        .history-container {
            background: linear-gradient(145deg, var(--bg-secondary), var(--bg-tertiary));
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: var(--shadow-lg);
            width: 100%;
            max-width: 1000px;
            border: 1px solid var(--border-color);
            margin: 0 auto;
        }

        .history-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            color: var(--text-primary);
        }

        .tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 2rem;
            background-color: var(--bg-tertiary);
            padding: 0.5rem;
            border-radius: 0.75rem;
            border: 1px solid var(--border-color);
        }

        .tab {
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            border-radius: 0.5rem;
            font-weight: 500;
            color: var(--text-secondary);
            transition: all 0.2s;
        }

        .tab.active {
            background: var(--primary-gradient);
            color: white;
            box-shadow: var(--shadow-orange);
        }

        .tab:hover:not(.active) {
            background-color: var(--bg-secondary);
        }

        .filters {
            background: linear-gradient(145deg, var(--bg-tertiary), var(--bg-secondary));
            padding: 1.5rem;
            border-radius: 0.75rem;
            margin-bottom: 1.5rem;
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            align-items: center;
            border: 1px solid var(--border-color);
        }

        .filter-group {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .filter-group label {
            font-weight: 500;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .filter-group input[type="date"],
        .filter-group select,
        .filter-group input[type="text"] {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            padding: 0.5rem;
            transition: all 0.2s;
        }

        .filter-group input[type="date"]:focus,
        .filter-group select:focus,
        .filter-group input[type="text"]:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(249, 115, 22, 0.2);
        }

        #applyFilters, #clearFilters {
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            font-weight: 500;
        }

        #applyFilters {
            background: var(--primary-gradient);
        }

        #clearFilters {
            background-color: var(--danger-color);
        }

        .session-list {
            list-style: none;
            padding: 0;
        }

        .session-item {
            padding: 1.5rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            transition: background-color 0.2s;
        }

        .session-item:hover {
            background-color: var(--bg-tertiary);
        }

        .session-tag {
            background: var(--primary-gradient);
            padding: 0.25rem 0.75rem;
            border-radius: 1rem;
            color: white;
            font-size: 0.875rem;
            font-weight: 500;
            box-shadow: var(--shadow-orange);
        }

        .completed-tasks {
            margin-top: 0.75rem;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .task-list {
            list-style: none;
            padding-left: 1rem;
            margin-top: 0.5rem;
        }

        .task-list li {
            position: relative;
            padding-left: 1.5rem;
            margin-bottom: 0.25rem;
        }

        .task-list li:before {
            content: "✓";
            position: absolute;
            left: 0;
            color: var(--primary-color);
            font-weight: bold;
        }

        .todo-container {
            margin-top: 1.5rem;
        }

        .todo-input {
            display: flex;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
        }

        .todo-input input {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            flex: 1;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            font-size: 1rem;
            transition: border-color 0.2s;
        }

        .todo-input input:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(249, 115, 22, 0.2);
        }

        .todo-list {
            list-style: none;
            padding: 0;
        }

        .todo-item {
            display: flex;
            align-items: center;
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
            gap: 0.75rem;
            transition: background-color 0.2s;
        }

        .todo-item:hover {
            background-color: var(--bg-tertiary);
        }

        .todo-item.completed {
            opacity: 0.7;
        }

        .todo-item.completed .todo-text {
            text-decoration: line-through;
            color: var(--text-secondary);
        }

        .todo-text {
            flex: 1;
            font-size: 1rem;
        }

        .todo-delete {
            color: var(--danger-color);
            cursor: pointer;
            padding: 0.5rem;
            font-size: 1.25rem;
            line-height: 1;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .todo-delete:hover {
            opacity: 1;
        }

        .todo-checkbox {
            width: 1.25rem;
            height: 1.25rem;
            cursor: pointer;
            accent-color: var(--primary-color);
        }

        .chart-container {
            margin-top: 2rem;
            height: 300px;
            background: linear-gradient(145deg, var(--bg-secondary), var(--bg-tertiary));
            padding: 1.5rem;
            border-radius: 0.75rem;
            border: 1px solid var(--border-color);
        }

        .gamification-container {
            background: linear-gradient(145deg, var(--bg-secondary), var(--bg-tertiary));
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: var(--shadow-lg);
            width: 100%;
            max-width: 1000px;
            border: 1px solid var(--border-color);
            margin: 0 auto;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background: var(--bg-tertiary);
            padding: 1.5rem;
            border-radius: 0.75rem;
            text-align: center;
            border: 1px solid var(--border-color);
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 0.5rem;
        }

        .stat-label {
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        .achievements-container {
            margin-top: 2rem;
        }

        .achievement-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
        }

        .achievement-card {
            background: var(--bg-tertiary);
            padding: 1rem;
            border-radius: 0.75rem;
            display: flex;
            align-items: center;
            gap: 1rem;
            border: 1px solid var(--border-color);
        }

        .achievement-icon {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }

        .achievement-bronze {
            background: var(--achievement-bronze);
        }

        .achievement-silver {
            background: var(--achievement-silver);
        }

        .achievement-gold {
            background: var(--achievement-gold);
        }

        .achievement-info {
            flex: 1;
        }

        .achievement-title {
            font-weight: 500;
            margin-bottom: 0.25rem;
        }

        .achievement-desc {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .achievement-progress {
            height: 4px;
            background: var(--bg-secondary);
            border-radius: 2px;
            margin-top: 0.5rem;
        }

        .achievement-progress-bar {
            height: 100%;
            background: var(--primary-gradient);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .level-indicator {
            position: relative;
            width: 100px;
            height: 100px;
            margin: 0 auto;
        }

        .level-circle {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: conic-gradient(var(--primary-color) 0% var(--progress), var(--bg-tertiary) var(--progress) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .level-inner {
            position: absolute;
            width: 80px;
            height: 80px;
            background: var(--bg-secondary);
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .level-number {
            font-size: 2rem;
            font-weight: 600;
            color: var(--primary-color);
        }

        .level-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .analytics-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 2rem;
        }

        .heatmap-container {
            background: linear-gradient(145deg, var(--bg-secondary), var(--bg-tertiary));
            padding: 1.5rem;
            border-radius: 0.75rem;
            border: 1px solid var(--border-color);
        }

        .heatmap-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text-primary);
        }

        .heatmap {
            display: grid;
            grid-template-columns: repeat(53, 1fr);
            gap: 3px;
            margin-bottom: 1rem;
        }

        .heatmap-day {
            width: 10px;
            height: 10px;
            border-radius: 2px;
            background-color: var(--heatmap-0);
            transition: background-color 0.2s;
        }

        .heatmap-legend {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        .legend-colors {
            display: flex;
            gap: 2px;
        }

        .legend-color {
            width: 10px;
            height: 10px;
            border-radius: 2px;
        }

        .character-container {
            position: relative;
            width: var(--character-size);
            height: var(--character-size);
            margin: 1rem auto;
            background: var(--bg-tertiary);
            border-radius: 50%;
            overflow: hidden;
            border: 3px solid var(--primary-color);
            box-shadow: 0 0 20px rgba(249, 115, 22, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .character {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4rem;
            transition: all 0.3s ease;
        }

        .character-idle {
            animation: idle 2s infinite ease-in-out;
        }

        .character-active {
            animation: active 1s infinite ease-in-out;
        }

        .character-levelup {
            animation: levelup 1s ease-out;
        }

        @keyframes idle {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        @keyframes active {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes levelup {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }

        .character-title {
            text-align: center;
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--primary-color);
            margin-top: 0.5rem;
            text-shadow: 0 2px 4px rgba(249, 115, 22, 0.2);
        }

        .character-description {
            text-align: center;
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }

            .timer-container {
                padding: 1.5rem;
            }

            .timer-display {
                font-size: 3rem;
            }

            .filters {
                flex-direction: column;
                align-items: stretch;
            }

            .filter-group {
                flex-direction: column;
                align-items: stretch;
            }

            .filter-group input[type="text"] {
                width: 100%;
            }

            .controls {
                flex-wrap: wrap;
            }

            button {
                flex: 1;
                min-width: 120px;
            }
        }

        .stats-overview {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .chart-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text-primary);
        }

        .chart-container {
            background: linear-gradient(145deg, var(--bg-secondary), var(--bg-tertiary));
            padding: 1.5rem;
            border-radius: 0.75rem;
            border: 1px solid var(--border-color);
            margin-bottom: 2rem;
        }

        /* Add these styles after the existing styles */
        .avatar-container {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 2rem;
            margin-top: 1.5rem;
            max-width: 1200px;
            margin: 0 auto;
        }

        .current-avatar {
            background: linear-gradient(145deg, var(--bg-secondary), var(--bg-tertiary));
            padding: 2rem;
            border-radius: 1rem;
            text-align: center;
            border: 1px solid var(--border-color);
            position: sticky;
            top: 2rem;
            height: fit-content;
        }

        .current-avatar h3 {
            color: var(--primary-color);
            margin-bottom: 1.5rem;
            font-size: 1.5rem;
            font-weight: 600;
        }

        .avatar-grid {
            background: linear-gradient(145deg, var(--bg-secondary), var(--bg-tertiary));
            padding: 2rem;
            border-radius: 1rem;
            border: 1px solid var(--border-color);
        }

        .avatar-grid h3 {
            color: var(--primary-color);
            margin-bottom: 1.5rem;
            font-size: 1.5rem;
            font-weight: 600;
        }

        .avatar-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 1.5rem;
            margin-top: 1.5rem;
        }

        .avatar-item {
            background: var(--bg-tertiary);
            padding: 1rem 0.75rem;
            border-radius: 0.75rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid var(--border-color);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 200px;
            padding-top: 2.5rem;
        }

        .avatar-item .character {
            font-size: 4rem;
            margin: 0;
            transition: transform 0.3s ease;
            flex-shrink: 0;
            line-height: 1;
        }

        .avatar-item .avatar-title {
            font-weight: 600;
            margin: 0;
            color: var(--text-primary);
            font-size: 1rem;
            line-height: 1.2;
            padding: 0 0.5rem;
            text-align: center;
            position: relative;
            z-index: 2;
        }

        .avatar-item .avatar-level {
            font-size: 0.875rem;
            color: var(--text-secondary);
            background: var(--bg-secondary);
            padding: 0.25rem 0.75rem;
            border-radius: 1rem;
            display: inline-block;
            margin: 0;
            position: absolute;
            top: 0.5rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2;
        }

        .avatar-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0));
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .avatar-item:hover::before {
            opacity: 1;
        }

        .avatar-item:hover {
            transform: translateY(-5px);
            box-shadow: var(--shadow-lg);
        }

        .avatar-item.selected {
            border: 2px solid var(--primary-color);
            box-shadow: var(--shadow-orange);
            background: linear-gradient(145deg, var(--bg-tertiary), var(--bg-secondary));
        }

        .avatar-item.locked {
            opacity: 0.7;
            cursor: not-allowed;
            background: linear-gradient(145deg, var(--bg-tertiary), var(--bg-secondary));
        }

        .avatar-item.locked:hover {
            transform: none;
            box-shadow: none;
        }

        .avatar-item .lock-icon {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            font-size: 1.25rem;
            color: var(--text-secondary);
            background: var(--bg-secondary);
            padding: 0.25rem;
            border-radius: 50%;
            box-shadow: var(--shadow-sm);
            z-index: 1;
        }

        .character-container {
            width: 150px;
            height: 150px;
            margin: 0 auto 1.5rem;
            background: var(--bg-tertiary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 3px solid var(--primary-color);
            box-shadow: var(--shadow-orange);
        }

        .character-container .character {
            font-size: 4rem;
        }

        .avatar-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 1.5rem;
            margin-top: 1.5rem;
        }

        @media (max-width: 768px) {
            .avatar-container {
                grid-template-columns: 1fr;
            }

            .current-avatar {
                position: relative;
                top: 0;
            }

            .avatar-list {
                grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            }

            .avatar-item {
                min-height: 200px;
                padding: 1rem 0.75rem;
            }

            .avatar-item .character {
                font-size: 3rem;
            }

            .avatar-item .avatar-title {
                font-size: 0.9rem;
            }
        }

        /* Add these styles after the existing styles */
        .project-title {
            font-size: 2.5rem;
            font-weight: 600;
            color: var(--primary-color);
            text-align: center;
            margin-bottom: 2rem;
            text-shadow: 0 2px 4px rgba(249, 115, 22, 0.2);
            letter-spacing: -0.025em;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
        }

        .project-logo {
            width: 120px;
            height: 120px;
            object-fit: contain;
            background: transparent;
        }

        /* Add these styles after the existing styles */
        .achievements-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            position: relative;
        }

        .achievements-header .history-title {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }

        .toggle-button {
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
            transition: transform 0.3s ease;
            margin-left: auto;
        }

        .toggle-button.collapsed {
            transform: rotate(-90deg);
        }

        .achievement-grid {
            transition: max-height 0.3s ease-out;
            overflow: hidden;
        }

        .achievement-grid.collapsed {
            max-height: 0;
        }

        .progression-path {
            background: linear-gradient(145deg, var(--bg-secondary), var(--bg-tertiary));
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: var(--shadow-lg);
            width: 100%;
            max-width: 1000px;
            border: 1px solid var(--border-color);
            margin: 0 auto;
            margin-top: 2rem;
            overflow: hidden;
        }

        .path-scroll-container {
            overflow-x: auto;
            padding: 1rem 0;
            scrollbar-width: thin;
            scrollbar-color: var(--primary-color) var(--bg-tertiary);
            position: relative;
            width: 100%;
            max-width: 1000px;
            margin: 0 auto;
            height: 200px; /* Fixed height to contain the path */
            scroll-behavior: smooth;
        }

        .path-container {
            display: flex;
            align-items: center;
            padding: 2rem 0;
            position: relative;
            transform: scale(0.83);
            transform-origin: center;
            margin: 0 auto;
            width: calc(100px * 100);
            justify-content: space-between;
            height: 100%; /* Ensure it fills the container */
        }

        .path-line {
            position: absolute;
            top: 50%;
            left: 50px;
            right: 50px;
            height: 4px;
            background: linear-gradient(90deg, 
                var(--primary-color) 0%,
                var(--primary-light) 50%,
                var(--primary-color) 100%
            );
            z-index: 1;
            box-shadow: 0 0 10px rgba(249, 115, 22, 0.3);
            transform: translateY(-50%);
        }

        .path-node {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            border: 3px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            z-index: 2;
            transition: all 0.3s ease;
            cursor: pointer;
            flex-shrink: 0;
        }

        .path-node:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(249, 115, 22, 0.4);
        }

        .path-node.completed {
            border-color: var(--primary-color);
            background: var(--bg-secondary);
            box-shadow: 0 0 15px rgba(249, 115, 22, 0.2);
        }

        .path-node.completed:hover {
            background: var(--primary-dark);
            border-color: var(--primary-light);
        }

        .path-node.current {
            border-color: var(--primary-color);
            background: var(--primary-color);
            transform: scale(1.2);
            box-shadow: var(--shadow-orange);
            animation: pulse 2s infinite;
        }

        .path-node.current:hover {
            transform: scale(1.3);
        }

        .path-node.locked {
            opacity: 0.7;
            cursor: not-allowed;
        }

        .path-node.locked:hover {
            transform: none;
            box-shadow: none;
        }

        .path-node .node-avatar {
            font-size: 2.5rem;
            transition: transform 0.3s ease;
        }

        .path-node:hover .node-avatar {
            transform: scale(1.1);
        }

        .path-node .node-level {
            position: absolute;
            bottom: -1.5rem;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.875rem;
            color: var(--text-secondary);
            background: var(--bg-tertiary);
            padding: 0.25rem 0.75rem;
            border-radius: 1rem;
            border: 1px solid var(--border-color);
            white-space: nowrap;
            transition: all 0.3s ease;
        }

        .path-node:hover .node-level {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-light);
        }

        .path-node.current .node-level {
            color: var(--primary-color);
            font-weight: 600;
            background: var(--bg-secondary);
            border-color: var(--primary-color);
        }

        .path-node .node-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-secondary);
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            font-size: 0.875rem;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            box-shadow: var(--shadow-md);
            z-index: 3;
        }

        .path-node:hover .node-tooltip {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(-10px);
        }

        .path-node .node-tooltip::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 10px solid var(--bg-secondary);
        }

        .path-navigation {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1rem;
        }

        .path-nav-button {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .path-nav-button:hover {
            background: var(--primary-color);
            border-color: var(--primary-light);
            color: white;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(249, 115, 22, 0.4);
            }
            70% {
                box-shadow: 0 0 0 20px rgba(249, 115, 22, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(249, 115, 22, 0);
            }
        }

        /* Add these styles after the existing styles */
        .achievements-container {
            background: linear-gradient(145deg, var(--bg-secondary), var(--bg-tertiary));
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: var(--shadow-lg);
            width: 100%;
            max-width: 1000px;
            border: 1px solid var(--border-color);
            margin: 2rem auto;
        }

        .achievement-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
            transition: max-height 0.3s ease-out;
            overflow: hidden;
        }

        .achievement-grid.collapsed {
            max-height: 0;
        }

        @media (max-width: 768px) {
            .achievement-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 480px) {
            .achievement-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Add these styles after the existing styles */
        .heatmap-pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            margin-top: 1rem;
            padding: 0.5rem;
        }

        .heatmap-pagination button {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .heatmap-pagination button:hover:not(:disabled) {
            background: var(--primary-color);
            border-color: var(--primary-light);
            color: white;
        }

        .heatmap-pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .heatmap-pagination span {
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        /* Update the window object with the new function */
        window.changeHeatmapPage = changeHeatmapPage;
    </style>
</head>
<body>
    <div class="container">
        <h1 class="project-title">
            <img src="assets/tudu.png" alt="Tudu Logo" class="project-logo">
            Tudu Time Tracker
        </h1>
        <div class="gamification-container">
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="character-container">
                        <div class="character" id="character"></div>
                    </div>
                    <div class="character-title" id="characterTitle">Novice Adventurer</div>
                    <div class="character-description" id="characterDescription">Level 1</div>
                    <div class="level-indicator">
                        <div class="level-circle" id="levelCircle">
                            <div class="level-inner">
                                <div class="level-number" id="levelNumber">1</div>
                                <div class="level-label">Level</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="currentStreak">0</div>
                    <div class="stat-label">Day Streak</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="totalXp">0</div>
                    <div class="stat-label">Total XP</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="achievementsCount">0</div>
                    <div class="stat-label">Achievements</div>
                </div>
            </div>

            <div class="progression-path">
                <h2 class="history-title">Progression Path</h2>
                <div class="path-scroll-container">
                    <div class="path-container" id="pathContainer">
                        <div class="path-line"></div>
                    </div>
                </div>
                <div class="path-navigation">
                    <button class="path-nav-button" onclick="scrollPath('left')">←</button>
                    <button class="path-nav-button" onclick="scrollPath('right')">→</button>
                </div>
            </div>
        </div>

        <div class="timer-container">
            <div class="timer-display" id="display">00:00:00</div>
            <div class="total-display">Total: <span id="totalDisplay">00:00:00</span></div>
            <input type="text" class="tag-input" id="tagInput" placeholder="Enter activity tag (e.g., 'Work', 'Study')">
            <div class="controls">
                <button id="startBtn">Start</button>
                <button id="pauseBtn">Pause</button>
                <button id="resetBtn">Reset</button>
            </div>
        </div>

        <div class="history-container">
            <div class="tabs">
                <div class="tab active" data-tab="sessions">Sessions</div>
                <div class="tab" data-tab="analytics">Analytics</div>
                <div class="tab" data-tab="todo">To-Do List</div>
                <div class="tab" data-tab="avatar">Avatar</div>
            </div>
            
            <div id="sessionsTab">
                <h2 class="history-title">Session History</h2>
                <div class="filters">
                    <div class="filter-group">
                        <label>Date Range:</label>
                        <input type="date" id="startDate">
                        <span>to</span>
                        <input type="date" id="endDate">
                    </div>
                    <div class="filter-group">
                        <label>Activity Tag:</label>
                        <select id="tagFilter">
                            <option value="">All Activities</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>Show Only Sessions With:</label>
                        <input type="text" id="taskFilter" placeholder="Completed tasks containing...">
                    </div>
                    <button id="applyFilters">Apply Filters</button>
                    <button id="clearFilters">Clear Filters</button>
                </div>
                <ul class="session-list" id="sessionList"></ul>
            </div>
            
            <div id="analyticsTab" style="display: none;">
                <h2 class="history-title">Activity Analytics</h2>
                <div class="analytics-grid">
                    <div class="stats-overview">
                        <div class="stat-card">
                            <div class="stat-value" id="avgSessionDuration">0:00:00</div>
                            <div class="stat-label">Average Session Duration</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="bestDay">-</div>
                            <div class="stat-label">Most Productive Day</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="totalSessions">0</div>
                            <div class="stat-label">Total Sessions</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="longestStreak">0</div>
                            <div class="stat-label">Longest Streak (days)</div>
                        </div>
                    </div>
                    <div class="chart-container">
                        <h3 class="chart-title">Activity Distribution by Tag</h3>
                        <canvas id="activityChart"></canvas>
                    </div>
                    <div class="chart-container">
                        <h3 class="chart-title">Daily Activity Distribution</h3>
                        <canvas id="dailyDistributionChart"></canvas>
                    </div>
                    <div class="chart-container">
                        <h3 class="chart-title">Productivity Trend (Last 30 Days)</h3>
                        <canvas id="trendChart"></canvas>
                    </div>
                    <div class="chart-container">
                        <h3 class="chart-title">Session Duration Distribution</h3>
                        <canvas id="durationChart"></canvas>
                    </div>
                    <div class="heatmap-container">
                        <h3 class="heatmap-title">Activity Heatmap</h3>
                        <div class="heatmap" id="activityHeatmap"></div>
                        <div class="heatmap-legend">
                            <span>Less</span>
                            <div class="legend-colors">
                                <div class="legend-color" style="background-color: var(--heatmap-0)"></div>
                                <div class="legend-color" style="background-color: var(--heatmap-1)"></div>
                                <div class="legend-color" style="background-color: var(--heatmap-2)"></div>
                                <div class="legend-color" style="background-color: var(--heatmap-3)"></div>
                                <div class="legend-color" style="background-color: var(--heatmap-4)"></div>
                            </div>
                            <span>More</span>
                        </div>
                    </div>
                </div>
            </div>

            <div id="todoTab" style="display: none;">
                <h2 class="history-title">To-Do List</h2>
                <div class="todo-container">
                    <div class="todo-input">
                        <input type="text" id="todoInput" placeholder="Add a new task...">
                        <button id="addTodoBtn">Add</button>
                    </div>
                    <ul class="todo-list" id="todoList"></ul>
                </div>
            </div>

            <div id="avatarTab" style="display: none;">
                <h2 class="history-title">Avatar Customization</h2>
                <div class="avatar-container">
                    <div class="current-avatar">
                        <h3>Current Avatar</h3>
                        <div class="character-container">
                            <div class="character" id="selectedCharacter"></div>
                        </div>
                        <div class="character-title" id="selectedCharacterTitle"></div>
                        <div class="character-description" id="selectedCharacterDescription"></div>
                    </div>
                    <div class="avatar-grid">
                        <h3>Available Avatars</h3>
                        <div class="avatar-list" id="avatarList"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="achievements-container">
            <div class="achievements-header">
                <h2 class="history-title">Achievements</h2>
                <button class="toggle-button" id="toggleAchievements">▼</button>
            </div>
            <div class="achievement-grid" id="achievementGrid"></div>
        </div>
    </div>

    <script>
        // Add this at the beginning of the script section
        window.changeHeatmapPage = changeHeatmapPage;

        let timer;
        let hours = 0;
        let minutes = 0;
        let seconds = 0;
        let isRunning = false;
        let totalSeconds = 0;
        let currentSessionStart = null;
        let currentTag = '';
        let animationFrameId = null;
        let lastUpdateTime = null;

        // Chart instances
        let activityChart = null;
        let dailyDistributionChart = null;
        let trendChart = null;
        let durationChart = null;

        // Days array for day of week calculations
        const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];

        const display = document.getElementById('display');
        const totalDisplay = document.getElementById('totalDisplay');
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const resetBtn = document.getElementById('resetBtn');
        const tagInput = document.getElementById('tagInput');
        const sessionList = document.getElementById('sessionList');
        const tabs = document.querySelectorAll('.tab');
        const sessionsTab = document.getElementById('sessionsTab');
        const analyticsTab = document.getElementById('analyticsTab');

        // Gamification variables
        let currentLevel = 1;
        let currentXp = 0;
        let currentStreak = 0;
        let lastActivityDate = null;
        const xpPerMinute = 1;
        const xpPerLevel = 1000;

        const achievements = [
            {
                id: 'first_session',
                title: 'First Timer',
                description: 'Complete your first session',
                icon: '⏱️',
                tier: 'bronze',
                progress: 0,
                maxProgress: 1,
                xpReward: 100,
                show: true
            },
            {
                id: 'total_10_hours',
                title: '10 Hours Club',
                description: 'Track 10 hours of activity',
                icon: '⏰',
                tier: 'bronze',
                progress: 0,
                maxProgress: 600,
                xpReward: 200,
                show: true
            },
            {
                id: 'streak_3',
                title: '3-Day Streak',
                description: 'Maintain a 3-day streak',
                icon: '🔥',
                tier: 'silver',
                progress: 0,
                maxProgress: 3,
                xpReward: 300,
                show: true
            },
            {
                id: 'total_50_hours',
                title: '50 Hours Club',
                description: 'Track 50 hours of activity',
                icon: '⌛',
                tier: 'silver',
                progress: 0,
                maxProgress: 3000,
                xpReward: 1000,
                show: false,
                prerequisite: 'total_10_hours'
            },
            {
                id: 'streak_7',
                title: '7-Day Streak',
                description: 'Maintain a 7-day streak',
                icon: '🌟',
                tier: 'gold',
                progress: 0,
                maxProgress: 7,
                xpReward: 700,
                show: false,
                prerequisite: 'streak_3'
            },
            {
                id: 'total_100_hours',
                title: '100 Hours Club',
                description: 'Track 100 hours of activity',
                icon: '🏆',
                tier: 'gold',
                progress: 0,
                maxProgress: 6000,
                xpReward: 2000,
                show: false,
                prerequisite: 'total_50_hours'
            },
            {
                id: 'streak_30',
                title: '30-Day Streak',
                description: 'Maintain a 30-day streak',
                icon: '🏆',
                tier: 'platinum',
                progress: 0,
                maxProgress: 30,
                xpReward: 3000,
                show: false,
                prerequisite: 'streak_7'
            },
            {
                id: 'early_bird',
                title: 'Early Bird',
                description: 'Start a session before 8 AM',
                icon: '🌅',
                tier: 'bronze',
                progress: 0,
                maxProgress: 1,
                xpReward: 150,
                show: true
            },
            {
                id: 'night_owl',
                title: 'Night Owl',
                description: 'Start a session after 10 PM',
                icon: '🌙',
                tier: 'bronze',
                progress: 0,
                maxProgress: 1,
                xpReward: 150,
                show: true
            },
            {
                id: 'focused_work',
                title: 'Focused Work',
                description: 'Complete 5 sessions of 30+ minutes without breaks',
                icon: '🎯',
                tier: 'bronze',
                progress: 0,
                maxProgress: 5,
                xpReward: 300,
                show: true
            },
            {
                id: 'task_completer',
                title: 'Task Completer',
                description: 'Complete 10 tasks during sessions',
                icon: '✅',
                tier: 'bronze',
                progress: 0,
                maxProgress: 10,
                xpReward: 200,
                show: true
            },
            {
                id: 'marathon',
                title: 'Marathon',
                description: 'Complete a 4-hour session',
                icon: '🏃',
                tier: 'silver',
                progress: 0,
                maxProgress: 1,
                xpReward: 500,
                show: false,
                prerequisite: 'total_10_hours'
            },
            {
                id: 'multitasker',
                title: 'Multitasker',
                description: 'Complete 5 different activities in one day',
                icon: '🎯',
                tier: 'silver',
                progress: 0,
                maxProgress: 5,
                xpReward: 400,
                show: false,
                prerequisite: 'focused_work'
            },
            {
                id: 'weekend_warrior',
                title: 'Weekend Warrior',
                description: 'Track activity on both weekend days',
                icon: '🎮',
                tier: 'bronze',
                progress: 0,
                maxProgress: 1,
                xpReward: 200,
                show: true
            },
            {
                id: 'morning_person',
                title: 'Morning Person',
                description: 'Complete 10 sessions before 9 AM',
                icon: '☀️',
                tier: 'silver',
                progress: 0,
                maxProgress: 10,
                xpReward: 500,
                show: false,
                prerequisite: 'early_bird'
            },
            {
                id: 'afternoon_delight',
                title: 'Afternoon Delight',
                description: 'Complete 10 sessions between 12 PM and 5 PM',
                icon: '🌤️',
                tier: 'silver',
                progress: 0,
                maxProgress: 10,
                xpReward: 500,
                show: false,
                prerequisite: 'focused_work'
            },
            {
                id: 'evening_explorer',
                title: 'Evening Explorer',
                description: 'Complete 10 sessions between 6 PM and 11 PM',
                icon: '🌆',
                tier: 'silver',
                progress: 0,
                maxProgress: 10,
                xpReward: 500,
                show: false,
                prerequisite: 'night_owl'
            },
            {
                id: 'activity_master',
                title: 'Activity Master',
                description: 'Track 10 different types of activities',
                icon: '🎨',
                tier: 'gold',
                progress: 0,
                maxProgress: 10,
                xpReward: 1000,
                show: false,
                prerequisite: 'multitasker'
            },
            {
                id: 'consistency_king',
                title: 'Consistency King',
                description: 'Maintain a streak for 3 consecutive weeks',
                icon: '👑',
                tier: 'gold',
                progress: 0,
                maxProgress: 21,
                xpReward: 1500,
                show: false,
                prerequisite: 'streak_7'
            },
            {
                id: 'weekday_warrior',
                title: 'Weekday Warrior',
                description: 'Track activity on all 5 weekdays',
                icon: '💼',
                tier: 'silver',
                progress: 0,
                maxProgress: 5,
                xpReward: 600,
                show: false,
                prerequisite: 'weekend_warrior'
            },
            {
                id: 'balanced_life',
                title: 'Balanced Life',
                description: 'Track activity on both weekdays and weekends',
                icon: '⚖️',
                tier: 'silver',
                progress: 0,
                maxProgress: 1,
                xpReward: 400,
                show: false,
                prerequisite: 'weekend_warrior'
            },
            {
                id: 'endurance_master',
                title: 'Endurance Master',
                description: 'Complete 5 sessions over 2 hours',
                icon: '🏋️',
                tier: 'gold',
                progress: 0,
                maxProgress: 5,
                xpReward: 1200,
                show: false,
                prerequisite: 'marathon'
            },
            {
                id: 'activity_architect',
                title: 'Activity Architect',
                description: 'Create 20 different activity tags',
                icon: '🏗️',
                tier: 'gold',
                progress: 0,
                maxProgress: 20,
                xpReward: 1500,
                show: false,
                prerequisite: 'activity_master'
            },
            {
                id: 'task_master',
                title: 'Task Master',
                icon: '✅',
                description: 'Complete 50 tasks during sessions',
                tier: 'silver',
                progress: 0,
                maxProgress: 50,
                xpReward: 800,
                show: false,
                prerequisite: 'task_completer'
            },
            {
                id: 'productivity_ninja',
                title: 'Productivity Ninja',
                description: 'Complete 3 sessions in a single day',
                icon: '🥷',
                tier: 'silver',
                progress: 0,
                maxProgress: 1,
                xpReward: 600,
                show: false,
                prerequisite: 'multitasker'
            },
            {
                id: 'time_traveler',
                title: 'Time Traveler',
                description: 'Track activity in all 4 quarters of the day',
                icon: '⏳',
                tier: 'gold',
                progress: 0,
                maxProgress: 1,
                xpReward: 1000,
                show: false,
                prerequisite: 'morning_person'
            },
            {
                id: 'quick_starter',
                title: 'Quick Starter',
                description: 'Complete 5 sessions under 15 minutes',
                icon: '⚡',
                tier: 'bronze',
                progress: 0,
                maxProgress: 5,
                xpReward: 200,
                show: true
            }
        ];

        // Daily challenges
        const dailyChallenges = [
            {
                id: 'morning_session',
                title: 'Morning Boost',
                description: 'Start a session before 9 AM',
                icon: '☀️',
                xpReward: 200,
                completed: false
            },
            {
                id: 'long_session',
                title: 'Endurance Test',
                description: 'Complete a 2-hour session',
                icon: '⏳',
                xpReward: 300,
                completed: false
            },
            {
                id: 'variety',
                title: 'Activity Variety',
                description: 'Track 3 different activities today',
                icon: '🎯',
                xpReward: 250,
                completed: false
            }
        ];

        // Special rewards
        const specialRewards = [
            {
                id: 'streak_booster',
                title: 'Streak Booster',
                description: 'Double XP for 24 hours',
                icon: '⚡',
                cost: 1000,
                active: false,
                duration: 24 * 60 * 60 * 1000 // 24 hours in milliseconds
            },
            {
                id: 'xp_multiplier',
                title: 'XP Multiplier',
                description: '1.5x XP for 12 hours',
                icon: '✨',
                cost: 500,
                active: false,
                duration: 12 * 60 * 60 * 1000 // 12 hours in milliseconds
            },
            {
                id: 'achievement_boost',
                title: 'Achievement Boost',
                description: 'Double achievement progress for 6 hours',
                icon: '🎯',
                cost: 300,
                active: false,
                duration: 6 * 60 * 60 * 1000 // 6 hours in milliseconds
            }
        ];

        // Character progression system
        const characterStates = [
            {
                level: 1,
                title: "Novice Adventurer",
                description: "Just starting your journey",
                idle: "🧙‍♂️",
                active: "🧙‍♂️",
                idleAnimation: "character-idle"
            },
            {
                level: 5,
                title: "Mystic Apprentice",
                description: "Learning the arcane arts",
                idle: "🔮",
                active: "🔮",
                idleAnimation: "character-idle"
            },
            {
                level: 10,
                title: "Elemental Master",
                description: "Commanding the forces of nature",
                idle: "🌪️",
                active: "🌪️",
                idleAnimation: "character-idle"
            },
            {
                level: 15,
                title: "Dragon Rider",
                description: "Soaring through the skies",
                idle: "🐉",
                active: "🐉",
                idleAnimation: "character-idle"
            },
            {
                level: 20,
                title: "Celestial Guardian",
                description: "Wielding cosmic power",
                idle: "✨",
                active: "✨",
                idleAnimation: "character-idle"
            },
            {
                level: 25,
                title: "Time Bender",
                description: "Mastering the flow of time",
                idle: "⏳",
                active: "⏳",
                idleAnimation: "character-idle"
            },
            {
                level: 30,
                title: "Cosmic Explorer",
                description: "Journeying through dimensions",
                idle: "🚀",
                active: "🚀",
                idleAnimation: "character-idle"
            },
            {
                level: 35,
                title: "Ancient Sage",
                description: "Holding ancient wisdom",
                idle: "📜",
                active: "📜",
                idleAnimation: "character-idle"
            },
            {
                level: 40,
                title: "Mythical Hero",
                description: "Legendary status achieved",
                idle: "🦸",
                active: "🦸",
                idleAnimation: "character-idle"
            },
            {
                level: 45,
                title: "Dungeon Master",
                description: "Ruler of all realms",
                idle: "👑",
                active: "👑",
                idleAnimation: "character-idle"
            },
            {
                level: 50,
                title: "Cosmic Guardian",
                description: "Universal power at your command",
                idle: "🌌",
                active: "🌌",
                idleAnimation: "character-idle"
            },
            {
                level: 55,
                title: "Time Lord",
                description: "Master of all time",
                idle: "⏰",
                active: "⏰",
                idleAnimation: "character-idle"
            },
            {
                level: 60,
                title: "Phoenix Knight",
                description: "Reborn in eternal flame",
                idle: "🔥",
                active: "🔥",
                idleAnimation: "character-idle"
            },
            {
                level: 65,
                title: "Storm Bringer",
                description: "Commanding the tempest",
                idle: "⚡",
                active: "⚡",
                idleAnimation: "character-idle"
            },
            {
                level: 70,
                title: "Void Walker",
                description: "Traversing the abyss",
                idle: "🌑",
                active: "🌑",
                idleAnimation: "character-idle"
            },
            {
                level: 75,
                title: "Star Forger",
                description: "Creating celestial bodies",
                idle: "⭐",
                active: "⭐",
                idleAnimation: "character-idle"
            },
            {
                level: 80,
                title: "Reality Weaver",
                description: "Shaping existence itself",
                idle: "🌀",
                active: "🌀",
                idleAnimation: "character-idle"
            },
            {
                level: 85,
                title: "Eternal Champion",
                description: "Beyond mortal limits",
                idle: "⚔️",
                active: "⚔️",
                idleAnimation: "character-idle"
            },
            {
                level: 90,
                title: "Omnipotent Being",
                description: "All-powerful existence",
                idle: "💫",
                active: "💫",
                idleAnimation: "character-idle"
            },
            {
                level: 95,
                title: "Cosmic Architect",
                description: "Designing universes",
                idle: "🌠",
                active: "🌠",
                idleAnimation: "character-idle"
            },
            {
                level: 100,
                title: "Supreme Deity",
                description: "The ultimate power",
                idle: "👁️",
                active: "👁️",
                idleAnimation: "character-idle"
            }
        ];

        // Add these variables after other const declarations
        const STORAGE_KEYS = {
            SESSIONS: 'sessions',
            TOTAL_TIME: 'totalTime',
            GAMIFICATION: 'gamification',
            TODOS: 'todos',
            SELECTED_AVATAR: 'selectedAvatar'
        };

        // Add cache object
        const cache = {
            sessions: null,
            totalTime: null,
            gamification: null,
            todos: null,
            selectedAvatar: null,
            lastUpdated: {}
        };

        // Add error handling function
        function handleStorageError(error, operation) {
            console.error(`Storage error during ${operation}:`, error);
        }

        // Add validation function
        function validateData(data, type) {
            try {
                switch (type) {
                    case 'sessions':
                        return Array.isArray(data) && data.every(session => 
                            session && typeof session === 'object' &&
                            'tag' in session && 'start' in session &&
                            'hours' in session && 'minutes' in session && 'seconds' in session
                        );
                    case 'todos':
                        return Array.isArray(data) && data.every(todo => 
                            todo && typeof todo === 'object' &&
                            'text' in todo && typeof todo.text === 'string' &&
                            'completed' in todo && typeof todo.completed === 'boolean'
                        );
                    case 'gamification':
                        return data && typeof data === 'object' &&
                            'level' in data && 'xp' in data &&
                            'streak' in data && 'achievements' in data;
                    default:
                        return true;
                }
            } catch (error) {
                console.error('Validation error:', error);
                return false;
            }
        }

        // Update storage functions
        function loadFromStorage(key) {
            try {
                if (cache[key] && Date.now() - cache.lastUpdated[key] < 5000) {
                    return cache[key];
                }

                const data = localStorage.getItem(key);
                if (!data) return null;

                const parsedData = JSON.parse(data);
                if (validateData(parsedData, key)) {
                    cache[key] = parsedData;
                    cache.lastUpdated[key] = Date.now();
                    return parsedData;
                }
                return null;
            } catch (error) {
                handleStorageError(error, `loading ${key}`);
                return null;
            }
        }

        function saveToStorage(key, data) {
            try {
                if (!validateData(data, key)) {
                    throw new Error('Invalid data format');
                }

                localStorage.setItem(key, JSON.stringify(data));
                cache[key] = data;
                cache.lastUpdated[key] = Date.now();
            } catch (error) {
                handleStorageError(error, `saving ${key}`);
            }
        }

        // Update existing functions to use new storage methods
        function loadSessions() {
            return loadFromStorage(STORAGE_KEYS.SESSIONS) || [];
        }

        function saveSessions(sessions) {
            saveToStorage(STORAGE_KEYS.SESSIONS, sessions);
        }

        function loadTotalTime() {
            const savedTotal = loadFromStorage(STORAGE_KEYS.TOTAL_TIME);
            if (savedTotal) {
                totalSeconds = parseInt(savedTotal);
                updateTotalDisplay();
            }
        }

        function saveTotalTime() {
            saveToStorage(STORAGE_KEYS.TOTAL_TIME, totalSeconds.toString());
        }

        function loadGamificationData() {
            const data = loadFromStorage(STORAGE_KEYS.GAMIFICATION);
            if (data) {
                currentLevel = data.level || 1;
                currentXp = data.xp || 0;
                currentStreak = data.streak || 0;
                lastActivityDate = data.lastActivityDate ? new Date(data.lastActivityDate) : null;
                achievements.forEach(achievement => {
                    const savedAchievement = data.achievements?.find(a => a.id === achievement.id);
                    if (savedAchievement) {
                        achievement.progress = savedAchievement.progress;
                    }
                });
            }
            updateGamificationUI();
        }

        function saveGamificationData() {
            const data = {
                level: currentLevel,
                xp: currentXp,
                streak: currentStreak,
                lastActivityDate: lastActivityDate,
                achievements: achievements
            };
            saveToStorage(STORAGE_KEYS.GAMIFICATION, data);
        }

        function loadTodos() {
            return loadFromStorage(STORAGE_KEYS.TODOS) || [];
        }

        function saveTodos(todos) {
            saveToStorage(STORAGE_KEYS.TODOS, todos);
        }

        // Add storage event listener for synchronization
        window.addEventListener('storage', (event) => {
            if (event.key && STORAGE_KEYS[event.key]) {
                // Clear cache for the changed key
                cache[event.key] = null;
                cache.lastUpdated[event.key] = 0;
                
                // Update UI based on the changed data
                switch (event.key) {
                    case STORAGE_KEYS.SESSIONS:
                        updateSessionList();
                        updateAnalytics();
                        break;
                    case STORAGE_KEYS.TOTAL_TIME:
                        loadTotalTime();
                        break;
                    case STORAGE_KEYS.GAMIFICATION:
                        loadGamificationData();
                        break;
                    case STORAGE_KEYS.TODOS:
                        updateTodoList();
                        break;
                }
            }
        });

        function formatTime(h, m, s) {
            return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        }

        function updateDisplay() {
            display.textContent = formatTime(hours, minutes, seconds);
        }

        function updateTotalDisplay() {
            const totalHours = Math.floor(totalSeconds / 3600);
            const totalMinutes = Math.floor((totalSeconds % 3600) / 60);
            const totalSecs = totalSeconds % 60;
            totalDisplay.textContent = formatTime(totalHours, totalMinutes, totalSecs);
        }

        function formatDate(date) {
            return new Date(date).toLocaleString();
        }

        function updateSessionList() {
            const sessions = loadSessions();
            // Sort sessions by date in descending order (newest first)
            const sortedSessions = sessions.sort((a, b) => new Date(b.start) - new Date(a.start));
            sessionList.innerHTML = sortedSessions.map(session => `
                <li class="session-item">
                    <div>
                        <span class="session-tag">${session.tag}</span>
                        <span>${formatDate(session.start)}</span>
                        ${session.completedTasks && session.completedTasks.length > 0 ? `
                            <div class="completed-tasks">
                                <strong>Completed:</strong>
                                <ul class="task-list">
                                    ${session.completedTasks.map(task => `<li>${task}</li>`).join('')}
                                </ul>
                            </div>
                        ` : ''}
                    </div>
                    <div>${formatTime(session.hours, session.minutes, session.seconds)}</div>
                </li>
            `).join('');
        }

        function updateAnalytics() {
            const sessions = loadSessions();
            const tagData = {};
            const dailyData = {};
            const trendData = {};
            const durationData = {
                '0-15m': 0,
                '15-30m': 0,
                '30-60m': 0,
                '1-2h': 0,
                '2h+': 0
            };
            
            let totalDuration = 0;
            let totalSessions = sessions.length;
            let longestStreak = 0;
            let currentStreak = 0;
            let lastDate = null;
            let bestDay = { date: null, duration: 0 };

            // Process sessions data
            sessions.forEach(session => {
                const duration = (session.hours * 3600) + (session.minutes * 60) + session.seconds;
                totalDuration += duration;

                // Tag distribution
                if (!tagData[session.tag]) {
                    tagData[session.tag] = 0;
                }
                tagData[session.tag] += duration;

                // Daily distribution
                const date = new Date(session.start);
                const dayOfWeek = days[date.getUTCDay()];
                if (!dailyData[dayOfWeek]) {
                    dailyData[dayOfWeek] = 0;
                }
                dailyData[dayOfWeek] += duration;

                // Trend data (last 30 days)
                const today = new Date();
                const thirtyDaysAgo = new Date(today);
                thirtyDaysAgo.setDate(today.getDate() - 30);
                if (date >= thirtyDaysAgo) {
                    const dateStr = date.toISOString().split('T')[0];
                    if (!trendData[dateStr]) {
                        trendData[dateStr] = 0;
                    }
                    trendData[dateStr] += duration;
                }

                // Duration distribution
                const minutes = duration / 60;
                if (minutes <= 15) durationData['0-15m']++;
                else if (minutes <= 30) durationData['15-30m']++;
                else if (minutes <= 60) durationData['30-60m']++;
                else if (minutes <= 120) durationData['1-2h']++;
                else durationData['2h+']++;

                // Best day calculation using UTC dates
                const utcDate = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));
                const dayStr = utcDate.toISOString().split('T')[0];
                if (!bestDay.date || duration > bestDay.duration) {
                    bestDay = { date: dayStr, duration };
                }

                // Streak calculation using UTC dates
                const sessionDate = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));
                sessionDate.setUTCHours(0, 0, 0, 0);
                
                if (!lastDate) {
                    currentStreak = 1;
                } else {
                    const diffTime = sessionDate - lastDate;
                    const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
                    
                    if (diffDays === 1) {
                        currentStreak++;
                    } else if (diffDays > 1) {
                        currentStreak = 1;
                    }
                }
                
                if (currentStreak > longestStreak) {
                    longestStreak = currentStreak;
                }
                
                lastDate = sessionDate;
            });

            // Update statistics
            const avgSessionSeconds = totalSessions > 0 ? Math.floor(totalDuration / totalSessions) : 0;
            const avgSessionHours = Math.floor(avgSessionSeconds / 3600);
            const avgSessionMinutes = Math.floor((avgSessionSeconds % 3600) / 60);
            
            document.getElementById('avgSessionDuration').textContent = 
                formatTime(avgSessionHours, avgSessionMinutes, 0);
            document.getElementById('bestDay').textContent = 
                bestDay.date ? new Date(bestDay.date).toLocaleDateString() : '-';
            document.getElementById('totalSessions').textContent = totalSessions;
            document.getElementById('longestStreak').textContent = longestStreak;

            // Update charts
            updateActivityChart(tagData);
            updateDailyDistributionChart(dailyData);
            updateTrendChart(trendData);
            updateDurationChart(durationData);
            updateHeatmap();
        }

        // Add these variables after other const declarations
        const chartConfigs = {
            activityChart: {
                type: 'bar',
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Hours'
                            }
                        }
                    }
                }
            },
            dailyDistributionChart: {
                type: 'line',
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Hours'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                usePointStyle: true,
                                pointStyle: 'circle'
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${context.parsed.y.toFixed(1)} hours`;
                                }
                            }
                        }
                    }
                }
            },
            trendChart: {
                type: 'line',
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Hours'
                            }
                        }
                    }
                }
            },
            durationChart: {
                type: 'doughnut',
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right'
                        }
                    }
                }
            }
        };

        // Add this function after other functions
        function destroyChart(chart) {
            if (chart) {
                chart.destroy();
            }
        }

        function updateActivityChart(tagData) {
            const ctx = document.getElementById('activityChart').getContext('2d');
            destroyChart(activityChart);

            const labels = Object.keys(tagData);
            const data = labels.map(tag => tagData[tag] / 3600); // Convert to hours

            activityChart = new Chart(ctx, {
                ...chartConfigs.activityChart,
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Hours Spent',
                        data: data,
                        backgroundColor: 'rgba(249, 115, 22, 0.5)',
                        borderColor: 'rgba(249, 115, 22, 1)',
                        borderWidth: 1
                    }]
                }
            });
        }

        function updateDailyDistributionChart(dailyData) {
            const ctx = document.getElementById('dailyDistributionChart').getContext('2d');
            destroyChart(dailyDistributionChart);

            const sessions = loadSessions();
            const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            
            // Create a map to store activity by day and tag
            const activityByDayAndTag = new Map();
            const uniqueTags = new Set();
            
            // Initialize the map structure
            days.forEach(day => {
                activityByDayAndTag.set(day, new Map());
            });

            // Process sessions data
            sessions.forEach(session => {
                const date = new Date(session.start);
                const dayOfWeek = days[date.getUTCDay()];
                const tag = session.tag;
                const duration = (session.hours * 3600) + (session.minutes * 60) + session.seconds;
                
                uniqueTags.add(tag);
                const dayData = activityByDayAndTag.get(dayOfWeek);
                dayData.set(tag, (dayData.get(tag) || 0) + duration);
            });

            // Generate colors for each tag
            const colors = [
                'rgba(249, 115, 22, 0.8)',   // Orange
                'rgba(22, 163, 74, 0.8)',    // Green
                'rgba(59, 130, 246, 0.8)',   // Blue
                'rgba(168, 85, 247, 0.8)',   // Purple
                'rgba(239, 68, 68, 0.8)',    // Red
                'rgba(234, 179, 8, 0.8)',    // Yellow
                'rgba(6, 182, 212, 0.8)',    // Cyan
                'rgba(244, 114, 182, 0.8)',  // Pink
                'rgba(120, 113, 108, 0.8)',  // Gray
                'rgba(34, 197, 94, 0.8)'     // Emerald
            ];

            // Create datasets for each tag
            const datasets = Array.from(uniqueTags).map((tag, index) => {
                const color = colors[index % colors.length];
                return {
                    label: tag,
                    data: days.map(day => {
                        const dayData = activityByDayAndTag.get(day);
                        const duration = dayData.get(tag) || 0;
                        return duration / 3600; // Convert to hours
                    }),
                    borderColor: color,
                    backgroundColor: color,
                    pointBackgroundColor: color,
                    pointBorderColor: '#fff',
                    pointRadius: 6,
                    pointHoverRadius: 8,
                    tension: 0.4,
                    fill: false
                };
            });

            dailyDistributionChart = new Chart(ctx, {
                ...chartConfigs.dailyDistributionChart,
                data: {
                    labels: days,
                    datasets: datasets
                }
            });
        }

        function updateTrendChart(trendData) {
            const ctx = document.getElementById('trendChart').getContext('2d');
            destroyChart(trendChart);

            // Generate all dates for the last 30 days
            const today = new Date();
            const thirtyDaysAgo = new Date(today);
            thirtyDaysAgo.setDate(today.getDate() - 30);
            
            const allDates = [];
            const currentDate = new Date(thirtyDaysAgo);
            while (currentDate <= today) {
                const dateStr = currentDate.toISOString().split('T')[0];
                allDates.push(dateStr);
                currentDate.setDate(currentDate.getDate() + 1);
            }

            // Create data array with 0 for dates without activity
            const data = allDates.map(date => (trendData[date] || 0) / 3600); // Convert to hours

            trendChart = new Chart(ctx, {
                ...chartConfigs.trendChart,
                data: {
                    labels: allDates.map(date => new Date(date).toLocaleDateString()),
                    datasets: [{
                        label: 'Daily Hours',
                        data: data,
                        borderColor: 'rgba(249, 115, 22, 1)',
                        backgroundColor: 'rgba(249, 115, 22, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                }
            });
        }

        function updateDurationChart(durationData) {
            const ctx = document.getElementById('durationChart').getContext('2d');
            destroyChart(durationChart);

            const labels = Object.keys(durationData);
            const data = Object.values(durationData);

            durationChart = new Chart(ctx, {
                ...chartConfigs.durationChart,
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: [
                            'rgba(249, 115, 22, 0.2)',
                            'rgba(249, 115, 22, 0.4)',
                            'rgba(249, 115, 22, 0.6)',
                            'rgba(249, 115, 22, 0.8)',
                            'rgba(249, 115, 22, 1)'
                        ],
                        borderColor: 'rgba(249, 115, 22, 1)',
                        borderWidth: 1
                    }]
                }
            });
        }

        // Add these variables after other const declarations
        const HEATMAP_PAGE_SIZE = 90; // Show 3 months at a time
        let currentHeatmapPage = 0;
        let heatmapData = null;

        // Add this function after other functions
        function initializeHeatmapData() {
            const sessions = loadSessions();
            const today = new Date();
            const oneYearAgo = new Date(today);
            oneYearAgo.setFullYear(today.getFullYear() - 1);

            // Create a map of daily activity using UTC dates
            const dailyActivity = new Map();
            sessions.forEach(session => {
                const date = new Date(session.start);
                const utcDate = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));
                const key = utcDate.toISOString().split('T')[0];
                const duration = session.hours * 3600 + session.minutes * 60 + session.seconds;
                dailyActivity.set(key, (dailyActivity.get(key) || 0) + duration);
            });

            // Find the maximum activity for a day
            const maxActivity = Math.max(...dailyActivity.values(), 0);
            // Define activity levels based on percentiles
            const activityLevels = [
                0,
                maxActivity * 0.2,  // 20th percentile
                maxActivity * 0.4,  // 40th percentile
                maxActivity * 0.6,  // 60th percentile
                maxActivity * 0.8   // 80th percentile
            ];

            // Pre-calculate all heatmap data
            const allDates = [];
            let currentDate = new Date(oneYearAgo);
            currentDate.setUTCHours(0, 0, 0, 0);
            
            while (currentDate <= today) {
                const dateKey = currentDate.toISOString().split('T')[0];
                const activity = dailyActivity.get(dateKey) || 0;
                
                // Determine the activity level
                let level = 0;
                for (let i = activityLevels.length - 1; i >= 0; i--) {
                    if (activity >= activityLevels[i]) {
                        level = i;
                        break;
                    }
                }

                allDates.push({
                    date: new Date(currentDate),
                    level: level,
                    hours: Math.round(activity / 3600 * 100) / 100
                });
                
                currentDate.setUTCDate(currentDate.getUTCDate() + 1);
            }

            return allDates;
        }

        function updateHeatmap() {
            if (!heatmapData) {
                heatmapData = initializeHeatmapData();
                // Calculate the current page based on today's date
                const today = new Date();
                today.setUTCHours(0, 0, 0, 0);
                const todayIndex = heatmapData.findIndex(item => 
                    item.date.getTime() === today.getTime()
                );
                if (todayIndex !== -1) {
                    currentHeatmapPage = Math.floor(todayIndex / HEATMAP_PAGE_SIZE);
                }
            }

            const heatmap = document.getElementById('activityHeatmap');
            const startIndex = currentHeatmapPage * HEATMAP_PAGE_SIZE;
            const endIndex = Math.min(startIndex + HEATMAP_PAGE_SIZE, heatmapData.length);
            const pageData = heatmapData.slice(startIndex, endIndex);

            let heatmapHTML = '';
            pageData.forEach(item => {
                const displayDate = item.date.toLocaleDateString();
                heatmapHTML += `<div class="heatmap-day" style="background-color: var(--heatmap-${item.level})" 
                    title="${displayDate}: ${item.hours} hours"></div>`;
            });

            heatmap.innerHTML = heatmapHTML;

            // Update pagination controls
            const totalPages = Math.ceil(heatmapData.length / HEATMAP_PAGE_SIZE);
            const paginationControls = document.createElement('div');
            paginationControls.className = 'heatmap-pagination';
            paginationControls.innerHTML = `
                <button onclick="changeHeatmapPage(-1)" ${currentHeatmapPage === 0 ? 'disabled' : ''}>← Previous</button>
                <span>Page ${currentHeatmapPage + 1} of ${totalPages}</span>
                <button onclick="changeHeatmapPage(1)" ${currentHeatmapPage === totalPages - 1 ? 'disabled' : ''}>Next →</button>
            `;

            // Remove existing pagination controls if they exist
            const existingPagination = document.querySelector('.heatmap-pagination');
            if (existingPagination) {
                existingPagination.remove();
            }

            heatmap.parentNode.appendChild(paginationControls);
        }

        function changeHeatmapPage(delta) {
            const totalPages = Math.ceil(heatmapData.length / HEATMAP_PAGE_SIZE);
            const newPage = currentHeatmapPage + delta;
            
            if (newPage >= 0 && newPage < totalPages) {
                currentHeatmapPage = newPage;
                updateHeatmap();
            }
        }

        function startTimer() {
            if (!isRunning) {
                isRunning = true;
                currentSessionStart = new Date();
                currentTag = tagInput.value.trim() || 'Untagged';
                checkDailyChallenges();
                updateCharacter();
                
                lastUpdateTime = Date.now();
                function updateTimer(timestamp) {
                    if (!isRunning) return;
                    
                    const now = Date.now();
                    const elapsed = now - lastUpdateTime;
                    
                    if (elapsed >= 1000) {
                        seconds++;
                        totalSeconds++;
                        const oldLevel = currentLevel;
                        currentXp += xpPerMinute;
                        
                        // Level up check
                        if (currentXp >= currentLevel * xpPerLevel) {
                            currentLevel++;
                            if (currentLevel > oldLevel) {
                                playLevelUpAnimation();
                            }
                        }
                        
                        if (seconds === 60) {
                            seconds = 0;
                            minutes++;
                        }
                        if (minutes === 60) {
                            minutes = 0;
                            hours++;
                        }
                        updateDisplay();
                        updateTotalDisplay();
                        saveTotalTime();
                        saveGamificationData();
                        updateGamificationUI();
                        lastUpdateTime = now;
                    }
                    
                    animationFrameId = requestAnimationFrame(updateTimer);
                }
                
                animationFrameId = requestAnimationFrame(updateTimer);
            }
        }

        function pauseTimer() {
            if (isRunning) {
                isRunning = false;
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                updateCharacter();
            }
        }

        function resetTimer() {
            if (hours > 0 || minutes > 0 || seconds > 0) {
                const sessions = loadSessions();
                const completedTasks = loadTodos().filter(todo => todo.completed);
                
                sessions.push({
                    tag: currentTag,
                    start: currentSessionStart,
                    hours,
                    minutes,
                    seconds,
                    completedTasks: completedTasks.map(todo => todo.text)
                });
                saveSessions(sessions);
                updateSessionList();
                updateAnalytics();
                updateStreak();
            }

            pauseTimer();
            hours = 0;
            minutes = 0;
            seconds = 0;
            currentSessionStart = null;
            currentTag = '';
            tagInput.value = '';
            updateDisplay();
        }

        // To-Do List functionality
        const todoInput = document.getElementById('todoInput');
        const addTodoBtn = document.getElementById('addTodoBtn');
        const todoList = document.getElementById('todoList');
        const todoTab = document.getElementById('todoTab');

        // Load todos from localStorage
        function loadTodos() {
            const savedTodos = localStorage.getItem('todos');
            return savedTodos ? JSON.parse(savedTodos) : [];
        }

        // Save todos to localStorage
        function saveTodos(todos) {
            localStorage.setItem('todos', JSON.stringify(todos));
        }

        function updateTodoList() {
            const todos = loadTodos();
            todoList.innerHTML = todos.map((todo, index) => `
                <li class="todo-item ${todo.completed ? 'completed' : ''}">
                    <input type="checkbox" class="todo-checkbox" ${todo.completed ? 'checked' : ''} data-index="${index}">
                    <span class="todo-text">${todo.text}</span>
                    <span class="todo-delete" data-index="${index}">×</span>
                </li>
            `).join('');

            // Add event listeners to new elements
            document.querySelectorAll('.todo-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', toggleTodo);
            });
            document.querySelectorAll('.todo-delete').forEach(deleteBtn => {
                deleteBtn.addEventListener('click', deleteTodo);
            });
        }

        function addTodo() {
            const text = todoInput.value.trim();
            if (text) {
                const todos = loadTodos();
                todos.push({ text, completed: false });
                saveTodos(todos);
                updateTodoList();
                todoInput.value = '';
            }
        }

        function toggleTodo(e) {
            const index = parseInt(e.target.dataset.index);
            const todos = loadTodos();
            todos[index].completed = !todos[index].completed;
            saveTodos(todos);
            updateTodoList();
        }

        function deleteTodo(e) {
            const index = parseInt(e.target.dataset.index);
            const todos = loadTodos();
            todos.splice(index, 1);
            saveTodos(todos);
            updateTodoList();
        }

        // Add event listeners for todo functionality
        addTodoBtn.addEventListener('click', addTodo);
        todoInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                addTodo();
            }
        });

        // Update tab switching to include todo tab
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                sessionsTab.style.display = 'none';
                analyticsTab.style.display = 'none';
                todoTab.style.display = 'none';
                
                if (tab.dataset.tab === 'sessions') {
                    sessionsTab.style.display = 'block';
                } else if (tab.dataset.tab === 'analytics') {
                    analyticsTab.style.display = 'block';
                } else if (tab.dataset.tab === 'todo') {
                    todoTab.style.display = 'block';
                }
            });
        });

        // Add these variables after other const declarations
        const startDateFilter = document.getElementById('startDate');
        const endDateFilter = document.getElementById('endDate');
        const tagFilter = document.getElementById('tagFilter');
        const taskFilter = document.getElementById('taskFilter');
        const applyFiltersBtn = document.getElementById('applyFilters');
        const clearFiltersBtn = document.getElementById('clearFilters');

        // Add this function after other functions
        function updateTagFilterOptions() {
            const sessions = loadSessions();
            const uniqueTags = [...new Set(sessions.map(session => session.tag))];
            
            tagFilter.innerHTML = `
                <option value="">All Activities</option>
                ${uniqueTags.map(tag => `<option value="${tag}">${tag}</option>`).join('')}
            `;
        }

        function filterSessions() {
            const sessions = loadSessions();
            const startDate = startDateFilter.value ? new Date(startDateFilter.value) : null;
            const endDate = endDateFilter.value ? new Date(endDateFilter.value) : null;
            const selectedTag = tagFilter.value;
            const taskSearch = taskFilter.value.toLowerCase();

            const filteredSessions = sessions.filter(session => {
                const sessionDate = new Date(session.start);
                
                // Date filter
                if (startDate && sessionDate < startDate) return false;
                if (endDate && sessionDate > endDate) return false;
                
                // Tag filter
                if (selectedTag && session.tag !== selectedTag) return false;
                
                // Task filter
                if (taskSearch && (!session.completedTasks || 
                    !session.completedTasks.some(task => 
                        task.toLowerCase().includes(taskSearch)))) {
                    return false;
                }
                
                return true;
            });

            displayFilteredSessions(filteredSessions);
        }

        function displayFilteredSessions(sessions) {
            sessionList.innerHTML = sessions.map(session => `
                <li class="session-item">
                    <div>
                        <span class="session-tag">${session.tag}</span>
                        <span>${formatDate(session.start)}</span>
                        ${session.completedTasks && session.completedTasks.length > 0 ? `
                            <div class="completed-tasks">
                                <strong>Completed:</strong>
                                <ul class="task-list">
                                    ${session.completedTasks.map(task => `<li>${task}</li>`).join('')}
                                </ul>
                            </div>
                        ` : ''}
                    </div>
                    <div>${formatTime(session.hours, session.minutes, session.seconds)}</div>
                </li>
            `).join('');
        }

        // Add these event listeners before the Initialize section
        applyFiltersBtn.addEventListener('click', filterSessions);
        clearFiltersBtn.addEventListener('click', () => {
            startDateFilter.value = '';
            endDateFilter.value = '';
            tagFilter.value = '';
            taskFilter.value = '';
            filterSessions();
        });

        // Load gamification data from localStorage
        function loadGamificationData() {
            const savedData = localStorage.getItem('gamification');
            if (savedData) {
                const data = JSON.parse(savedData);
                currentLevel = data.level || 1;
                currentXp = data.xp || 0;
                currentStreak = data.streak || 0;
                lastActivityDate = data.lastActivityDate ? new Date(data.lastActivityDate) : null;
                achievements.forEach(achievement => {
                    const savedAchievement = data.achievements?.find(a => a.id === achievement.id);
                    if (savedAchievement) {
                        achievement.progress = savedAchievement.progress;
                    }
                });
            }
            updateGamificationUI();
        }

        // Save gamification data to localStorage
        function saveGamificationData() {
            const data = {
                level: currentLevel,
                xp: currentXp,
                streak: currentStreak,
                lastActivityDate: lastActivityDate,
                achievements: achievements
            };
            localStorage.setItem('gamification', JSON.stringify(data));
        }

        // Update gamification UI
        function updateGamificationUI() {
            // Update character-related elements
            const character = document.getElementById('character');
            const characterTitle = document.getElementById('characterTitle');
            const characterDescription = document.getElementById('characterDescription');
            const levelNumber = document.getElementById('levelNumber');
            const levelCircle = document.getElementById('levelCircle');
            const currentStreakElement = document.getElementById('currentStreak');
            const totalXpElement = document.getElementById('totalXp');
            const achievementsCountElement = document.getElementById('achievementsCount');

            if (character && characterTitle && characterDescription && levelNumber && levelCircle) {
                const levelProgress = (currentXp % xpPerLevel) / xpPerLevel * 100;
                levelCircle.style.setProperty('--progress', `${levelProgress}%`);
                levelNumber.textContent = currentLevel;
                updateCharacter();
            }

            if (currentStreakElement) {
                currentStreakElement.textContent = currentStreak;
            }

            if (totalXpElement) {
                totalXpElement.textContent = currentXp;
            }

            // Update achievement visibility based on prerequisites
            achievements.forEach(achievement => {
                if (achievement.prerequisite) {
                    const prerequisite = achievements.find(a => a.id === achievement.prerequisite);
                    if (prerequisite && prerequisite.progress >= prerequisite.maxProgress) {
                        achievement.show = true;
                    }
                }
            });

            if (achievementsCountElement) {
                achievementsCountElement.textContent = achievements.filter(a => a.progress >= a.maxProgress).length;
            }

            const achievementGrid = document.getElementById('achievementGrid');
            if (achievementGrid) {
                achievementGrid.innerHTML = achievements
                    .filter(achievement => achievement.show)
                    .map(achievement => `
                        <div class="achievement-card">
                            <div class="achievement-icon achievement-${achievement.tier}">
                                ${achievement.icon}
                            </div>
                            <div class="achievement-info">
                                <div class="achievement-title">${achievement.title}</div>
                                <div class="achievement-desc">${achievement.description}</div>
                                <div class="achievement-progress">
                                    <div class="achievement-progress-bar" style="width: ${(achievement.progress / achievement.maxProgress) * 100}%"></div>
                                </div>
                            </div>
                        </div>
                    `).join('');
            }

            updateProgressionPath();
        }

        // Add checkDailyChallenges function
        function checkDailyChallenges() {
            const now = new Date();
            const hour = now.getHours();
            const sessions = loadSessions();
            const todaySessions = sessions.filter(session => {
                const sessionDate = new Date(session.start);
                return sessionDate.toDateString() === now.toDateString();
            });
            const uniqueTags = new Set(todaySessions.map(session => session.tag));

            // Morning Boost challenge
            if (hour < 9) {
                const morningChallenge = dailyChallenges.find(c => c.id === 'morning_session');
                if (morningChallenge && !morningChallenge.completed) {
                    morningChallenge.completed = true;
                    currentXp += morningChallenge.xpReward;
                }
            }

            // Endurance Test challenge
            const longSessionChallenge = dailyChallenges.find(c => c.id === 'long_session');
            if (longSessionChallenge && !longSessionChallenge.completed) {
                const hasLongSession = todaySessions.some(session => 
                    session.hours >= 2 || (session.hours === 1 && session.minutes >= 30)
                );
                if (hasLongSession) {
                    longSessionChallenge.completed = true;
                    currentXp += longSessionChallenge.xpReward;
                }
            }

            // Activity Variety challenge
            const varietyChallenge = dailyChallenges.find(c => c.id === 'variety');
            if (varietyChallenge && !varietyChallenge.completed) {
                if (uniqueTags.size >= 3) {
                    varietyChallenge.completed = true;
                    currentXp += varietyChallenge.xpReward;
                }
            }

            saveGamificationData();
            updateGamificationUI();
        }

        // Update streak
        function updateStreak() {
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            if (!lastActivityDate) {
                currentStreak = 1;
            } else {
                const lastDate = new Date(lastActivityDate);
                lastDate.setHours(0, 0, 0, 0);
                
                const diffTime = today - lastDate;
                const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

                if (diffDays === 1) {
                    currentStreak++;
                } else if (diffDays > 1) {
                    currentStreak = 1;
                }
            }

            lastActivityDate = today;
            updateAchievements();
            saveGamificationData();
            updateGamificationUI();
        }

        // Update achievements
        function updateAchievements() {
            const sessions = loadSessions();
            
            // First session achievement
            const firstSessionAchievement = achievements.find(a => a.id === 'first_session');
            if (firstSessionAchievement && sessions.length > 0) {
                firstSessionAchievement.progress = 1;
            }

            // Streak achievements
            const streak3Achievement = achievements.find(a => a.id === 'streak_3');
            const streak7Achievement = achievements.find(a => a.id === 'streak_7');
            if (streak3Achievement) streak3Achievement.progress = Math.min(currentStreak, 3);
            if (streak7Achievement) streak7Achievement.progress = Math.min(currentStreak, 7);

            // Total hours achievements
            const totalMinutes = totalSeconds / 60;
            const total10HoursAchievement = achievements.find(a => a.id === 'total_10_hours');
            const total50HoursAchievement = achievements.find(a => a.id === 'total_50_hours');
            const total100HoursAchievement = achievements.find(a => a.id === 'total_100_hours');
            
            if (total10HoursAchievement) total10HoursAchievement.progress = Math.min(totalMinutes, 600);
            if (total50HoursAchievement) total50HoursAchievement.progress = Math.min(totalMinutes, 3000);
            if (total100HoursAchievement) total100HoursAchievement.progress = Math.min(totalMinutes, 6000);

            // Time-based achievements
            const morningPerson = achievements.find(a => a.id === 'morning_person');
            const afternoonDelight = achievements.find(a => a.id === 'afternoon_delight');
            const eveningExplorer = achievements.find(a => a.id === 'evening_explorer');
            const timeTraveler = achievements.find(a => a.id === 'time_traveler');

            let morningSessions = 0;
            let afternoonSessions = 0;
            let eveningSessions = 0;
            let hasEarlyMorning = false;
            let hasLateMorning = false;
            let hasEarlyAfternoon = false;
            let hasLateAfternoon = false;

            sessions.forEach(session => {
                const hour = new Date(session.start).getHours();
                
                // Morning sessions (before 9 AM)
                if (hour < 9) {
                    morningSessions++;
                    hasEarlyMorning = true;
                }
                // Late morning (9 AM - 12 PM)
                else if (hour < 12) {
                    hasLateMorning = true;
                }
                // Early afternoon (12 PM - 3 PM)
                else if (hour < 15) {
                    afternoonSessions++;
                    hasEarlyAfternoon = true;
                }
                // Late afternoon (3 PM - 5 PM)
                else if (hour < 17) {
                    afternoonSessions++;
                    hasLateAfternoon = true;
                }
                // Evening (6 PM - 11 PM)
                else if (hour >= 18 && hour < 23) {
                    eveningSessions++;
                }
            });

            if (morningPerson) morningPerson.progress = Math.min(morningSessions, 10);
            if (afternoonDelight) afternoonDelight.progress = Math.min(afternoonSessions, 10);
            if (eveningExplorer) eveningExplorer.progress = Math.min(eveningSessions, 10);
            if (timeTraveler) timeTraveler.progress = hasEarlyMorning && hasLateMorning && hasEarlyAfternoon && hasLateAfternoon ? 1 : 0;

            // Activity variety achievements
            const uniqueTags = new Set(sessions.map(session => session.tag));
            const activityMaster = achievements.find(a => a.id === 'activity_master');
            const activityArchitect = achievements.find(a => a.id === 'activity_architect');
            
            if (activityMaster) activityMaster.progress = Math.min(uniqueTags.size, 10);
            if (activityArchitect) activityArchitect.progress = Math.min(uniqueTags.size, 20);

            // Session duration achievements
            const quickStarter = achievements.find(a => a.id === 'quick_starter');
            const enduranceMaster = achievements.find(a => a.id === 'endurance_master');
            
            let quickSessions = 0;
            let longSessions = 0;
            
            sessions.forEach(session => {
                const duration = session.hours * 60 + session.minutes;
                if (duration <= 15) quickSessions++;
                if (duration >= 120) longSessions++;
            });

            if (quickStarter) quickStarter.progress = Math.min(quickSessions, 5);
            if (enduranceMaster) enduranceMaster.progress = Math.min(longSessions, 5);

            // Task completion achievement
            const taskMaster = achievements.find(a => a.id === 'task_master');
            let completedTasks = 0;
            
            sessions.forEach(session => {
                if (session.completedTasks) {
                    completedTasks += session.completedTasks.length;
                }
            });

            if (taskMaster) taskMaster.progress = Math.min(completedTasks, 50);

            // Daily activity achievements
            const weekdayWarrior = achievements.find(a => a.id === 'weekday_warrior');
            const balancedLife = achievements.find(a => a.id === 'balanced_life');
            const productivityNinja = achievements.find(a => a.id === 'productivity_ninja');
            
            let weekdayCount = 0;
            let hasWeekend = false;
            let hasWeekday = false;
            let maxSessionsPerDay = 0;
            const sessionsByDay = new Map();
            
            sessions.forEach(session => {
                const date = new Date(session.start);
                const dayOfWeek = date.getDay();
                const dateStr = date.toDateString();
                
                // Count sessions per day
                sessionsByDay.set(dateStr, (sessionsByDay.get(dateStr) || 0) + 1);
                
                // Track weekday/weekend activity
                if (dayOfWeek >= 1 && dayOfWeek <= 5) {
                    hasWeekday = true;
                    weekdayCount++;
                } else {
                    hasWeekend = true;
                }
            });

            // Find maximum sessions in a single day
            sessionsByDay.forEach(count => {
                maxSessionsPerDay = Math.max(maxSessionsPerDay, count);
            });

            if (weekdayWarrior) weekdayWarrior.progress = Math.min(weekdayCount, 5);
            if (balancedLife) balancedLife.progress = hasWeekday && hasWeekend ? 1 : 0;
            if (productivityNinja) productivityNinja.progress = maxSessionsPerDay >= 3 ? 1 : 0;

            // Consistency achievement
            const consistencyKing = achievements.find(a => a.id === 'consistency_king');
            if (consistencyKing) consistencyKing.progress = Math.min(currentStreak, 21);
        }

        // Update character
        function updateCharacter() {
            const character = document.getElementById('character');
            const characterTitle = document.getElementById('characterTitle');
            const characterDescription = document.getElementById('characterDescription');
            
            // Find the appropriate character state
            let currentState = characterStates[0];
            for (let i = characterStates.length - 1; i >= 0; i--) {
                if (currentLevel >= characterStates[i].level) {
                    currentState = characterStates[i];
                    break;
                }
            }

            // Update character appearance
            character.textContent = isRunning ? currentState.active : currentState.idle;
            character.className = `character ${isRunning ? 'character-active' : currentState.idleAnimation}`;
            
            // Update character info
            characterTitle.textContent = currentState.title;
            characterDescription.textContent = `${currentState.description} (Level ${currentLevel})`;
        }

        // Add level up animation
        function playLevelUpAnimation() {
            const character = document.getElementById('character');
            character.classList.add('character-levelup');
            setTimeout(() => {
                character.classList.remove('character-levelup');
            }, 1000);
        }

        // Initialize
        loadTotalTime();
        updateSessionList();
        updateAnalytics();
        updateTodoList();
        updateTagFilterOptions();
        startBtn.addEventListener('click', startTimer);
        pauseBtn.addEventListener('click', pauseTimer);
        resetBtn.addEventListener('click', resetTimer);
        loadGamificationData();

        // Add these variables after other const declarations
        const avatarTab = document.getElementById('avatarTab');
        const selectedCharacter = document.getElementById('selectedCharacter');
        const selectedCharacterTitle = document.getElementById('selectedCharacterTitle');
        const selectedCharacterDescription = document.getElementById('selectedCharacterDescription');
        const avatarList = document.getElementById('avatarList');

        // Add this function after other functions
        function updateAvatarSelection() {
            const currentState = characterStates.find(state => state.level <= currentLevel);
            const savedAvatar = localStorage.getItem('selectedAvatar');
            let selectedState = currentState;

            if (savedAvatar) {
                const savedState = characterStates.find(state => state.level === parseInt(savedAvatar));
                if (savedState && currentLevel >= savedState.level) {
                    selectedState = savedState;
                }
            }

            if (selectedState) {
                selectedCharacter.textContent = selectedState.idle;
                selectedCharacterTitle.textContent = selectedState.title;
                selectedCharacterDescription.textContent = selectedState.description;
                
                // Update main character display
                const mainCharacter = document.getElementById('character');
                const mainCharacterTitle = document.getElementById('characterTitle');
                const mainCharacterDescription = document.getElementById('characterDescription');
                
                mainCharacter.textContent = isRunning ? selectedState.active : selectedState.idle;
                mainCharacter.className = `character ${isRunning ? 'character-active' : selectedState.idleAnimation}`;
                mainCharacterTitle.textContent = selectedState.title;
                mainCharacterDescription.textContent = `${selectedState.description} (Level ${currentLevel})`;
            }

            // Update avatar list
            avatarList.innerHTML = characterStates.map(state => {
                const isUnlocked = currentLevel >= state.level;
                const isSelected = selectedState && state.level === selectedState.level;
                
                return `
                    <div class="avatar-item ${isUnlocked ? '' : 'locked'} ${isSelected ? 'selected' : ''}" 
                         data-level="${state.level}" ${isUnlocked ? 'onclick="selectAvatar(this)"' : ''}>
                        ${!isUnlocked ? '<span class="lock-icon">🔒</span>' : ''}
                        <div class="character">${state.idle}</div>
                        <div class="avatar-title">${state.title}</div>
                        <div class="avatar-level">Level ${state.level}</div>
                    </div>
                `;
            }).join('');
        }

        function selectAvatar(element) {
            const level = parseInt(element.dataset.level);
            const state = characterStates.find(s => s.level === level);
            
            if (state) {
                // Save selected avatar
                localStorage.setItem('selectedAvatar', level.toString());
                
                selectedCharacter.textContent = state.idle;
                selectedCharacterTitle.textContent = state.title;
                selectedCharacterDescription.textContent = state.description;
                
                // Update main character display
                const mainCharacter = document.getElementById('character');
                const mainCharacterTitle = document.getElementById('characterTitle');
                const mainCharacterDescription = document.getElementById('characterDescription');
                
                mainCharacter.textContent = isRunning ? state.active : state.idle;
                mainCharacter.className = `character ${isRunning ? 'character-active' : state.idleAnimation}`;
                mainCharacterTitle.textContent = state.title;
                mainCharacterDescription.textContent = `${state.description} (Level ${currentLevel})`;
                
                // Update selected state in the list
                document.querySelectorAll('.avatar-item').forEach(item => {
                    item.classList.remove('selected');
                });
                element.classList.add('selected');
            }
        }

        // Update the tab switching code to include the avatar tab
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                sessionsTab.style.display = 'none';
                analyticsTab.style.display = 'none';
                todoTab.style.display = 'none';
                avatarTab.style.display = 'none';
                
                if (tab.dataset.tab === 'sessions') {
                    sessionsTab.style.display = 'block';
                } else if (tab.dataset.tab === 'analytics') {
                    analyticsTab.style.display = 'block';
                } else if (tab.dataset.tab === 'todo') {
                    todoTab.style.display = 'block';
                } else if (tab.dataset.tab === 'avatar') {
                    avatarTab.style.display = 'block';
                    updateAvatarSelection();
                }
            });
        });

        // Update the Initialize section to include avatar initialization
        loadTotalTime();
        updateSessionList();
        updateAnalytics();
        updateTodoList();
        updateTagFilterOptions();
        startBtn.addEventListener('click', startTimer);
        pauseBtn.addEventListener('click', pauseTimer);
        resetBtn.addEventListener('click', resetTimer);
        loadGamificationData();
        updateAvatarSelection();

        // Add this after the updateGamificationUI function
        function toggleAchievements() {
            const achievementGrid = document.getElementById('achievementGrid');
            const toggleButton = document.getElementById('toggleAchievements');
            
            achievementGrid.classList.toggle('collapsed');
            toggleButton.classList.toggle('collapsed');
        }

        // Add this to the Initialize section
        document.getElementById('toggleAchievements').addEventListener('click', toggleAchievements);

        // Add this after the updateGamificationUI function
        function initializeProgressionPath() {
            const pathContainer = document.getElementById('pathContainer');
            const currentLevel = parseInt(document.getElementById('levelNumber').textContent);
            const startLevel = 1;
            const endLevel = 100;
            
            let pathHTML = '<div class="path-line"></div>';
            
            for (let level = startLevel; level <= endLevel; level++) {
                const state = characterStates.find(s => s.level === level) || characterStates[0];
                const isCompleted = level < currentLevel;
                const isCurrent = level === currentLevel;
                const isLocked = level > currentLevel;
                const isMilestone = level % 5 === 0 || level === currentLevel;
                
                pathHTML += `
                    <div class="path-node ${isCompleted ? 'completed' : ''} ${isCurrent ? 'current' : ''} ${isLocked ? 'locked' : ''}"
                         onclick="handleNodeClick(${level})">
                        ${isMilestone ? `<div class="node-avatar">${state.idle}</div>` : ''}
                        <div class="node-level">Level ${level}</div>
                        <div class="node-tooltip">
                            <div>${state.title}</div>
                            <div style="color: var(--text-secondary); font-size: 0.75rem;">${state.description}</div>
                        </div>
                    </div>
                `;
            }
            
            pathContainer.innerHTML = pathHTML;
            
            // Set initial scroll position to center the current level
            const scrollContainer = document.querySelector('.path-scroll-container');
            const currentNode = pathContainer.querySelector('.path-node.current');
            if (currentNode && scrollContainer) {
                const nodeRect = currentNode.getBoundingClientRect();
                const containerRect = scrollContainer.getBoundingClientRect();
                const scrollLeft = nodeRect.left - containerRect.left - (containerRect.width / 2) + (nodeRect.width / 2);
                scrollContainer.scrollLeft = scrollLeft;
            }
        }

        function updateProgressionPath() {
            const pathContainer = document.getElementById('pathContainer');
            const currentLevel = parseInt(document.getElementById('levelNumber').textContent);
            const startLevel = 1;
            const endLevel = 100;
            
            let pathHTML = '<div class="path-line"></div>';
            
            for (let level = startLevel; level <= endLevel; level++) {
                const state = characterStates.find(s => s.level === level) || characterStates[0];
                const isCompleted = level < currentLevel;
                const isCurrent = level === currentLevel;
                const isLocked = level > currentLevel;
                const isMilestone = level % 5 === 0 || level === currentLevel;
                
                pathHTML += `
                    <div class="path-node ${isCompleted ? 'completed' : ''} ${isCurrent ? 'current' : ''} ${isLocked ? 'locked' : ''}"
                         onclick="handleNodeClick(${level})">
                        ${isMilestone ? `<div class="node-avatar">${state.idle}</div>` : ''}
                        <div class="node-level">Level ${level}</div>
                        <div class="node-tooltip">
                            <div>${state.title}</div>
                            <div style="color: var(--text-secondary); font-size: 0.75rem;">${state.description}</div>
                        </div>
                    </div>
                `;
            }
            
            pathContainer.innerHTML = pathHTML;
        }

        // Update the Initialize section to use initializeProgressionPath instead of updateProgressionPath
        loadTotalTime();
        updateSessionList();
        updateAnalytics();
        updateTodoList();
        updateTagFilterOptions();
        startBtn.addEventListener('click', startTimer);
        pauseBtn.addEventListener('click', pauseTimer);
        resetBtn.addEventListener('click', resetTimer);
        loadGamificationData();
        updateAvatarSelection();
        initializeProgressionPath();

        // Initialize achievement grid as expanded
        const achievementGrid = document.getElementById('achievementGrid');
        const toggleButton = document.getElementById('toggleAchievements');
        if (achievementGrid && toggleButton) {
            achievementGrid.classList.remove('collapsed');
            toggleButton.classList.remove('collapsed');
        }

        function handleNodeClick(level) {
            const state = characterStates.find(s => s.level === level);
            if (state && level <= currentLevel) {
                // Update selected avatar
                localStorage.setItem('selectedAvatar', level.toString());
                updateAvatarSelection();
            }
        };
    </script>
</body>
</html> 